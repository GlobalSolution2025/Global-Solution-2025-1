# FIAP - Faculdade de Inform√°tica e Administra√ß√£o Paulista 

<p align="center">
  <a href="https://www.fiap.com.br/">
    ![logo-fiap](https://github.com/user-attachments/assets/e188b677-da62-4d5a-9c55-19ded1723126)
  </a>
</p>


<br>

# üî• Fire Monitoring - Sistema de Alerta de Inc√™ndios (Global Solution 2025/1)
## üë®‚Äçüéì **Integrantes:**

- Ant√¥nio Ancelmo Neto barros
```
 - RM: rm563683
 - E-mail: antonio.anbarros@gmail.com
 - GitHub: [@AntonioBarros19](https://github.com/AntonioBarros19)
```
- Beatriz Pilecarte de Melo
```
 - RM: rm564952
 - E-mail: beatrizpilecartedemelo@gmail.com
 - GitHub: [@BPilecarte](https://github.com/BPilecarte)
```
- Francismar Alves Martins Junior
```
 - RM: m562869
 - E-mail: yggdrasil.git@gmail.com
 - GitHub: [@yggdrasilGit](https://github.com/yggdrasilGit
```
- Matheus Soares Bento da Silva
```
 - RM: rm565540
 - E-mail: matheusbento044@gmail.com
 - GitHub: [matheusbento044](https://github.com/matheusbento04)
```
- Vitor Eiji Fernandes Teruia
```
- RM: rm563683
- E-mail: vitorfer2018@gmail.com
- GitHub: [@Vitor985-hub](https://github.com/Vitor985-hub)
```

## üë©‚Äçüè´ Professores:
### Tutor(a) 
- <a href="https://www.linkedin.com/in/leonardoorabona/">Leonardo Ruiz Orabona</a>
### Coordenador(a)
- <a href="https://www.linkedin.com/company/inova-fusc">Andr√© Godoi Chiovato</a>


## üìú **Descri√ß√£o**

Os inc√™ndios florestais t√™m se intensificado nos √∫ltimos anos, gerando impactos ambientais, econ√¥micos e sociais significativos. As principais causas incluem mudan√ßas clim√°ticas, a√ß√£o humana e per√≠odos prolongados de seca.

O desafio do nosso projeto √© desenvolver uma solu√ß√£o capaz de **prever e detectar inc√™ndios florestais antes que eles se tornem incontrol√°veis**, utilizando uma combina√ß√£o de sensores ambientais, microcontroladores (ESP32) e algoritmos de Machine Learning.

## üéØ **Justificativa**

* Preservar o meio ambiente, a fauna, a flora e vidas humanas;
* Prever inc√™ndios antes que eles ocorram;
* Utilizar tecnologia acess√≠vel e de baixo custo para monitoramento cont√≠nuo e preven√ß√£o de desastres.


---
## üîß **Tecnologias Utilizadas**

- ESP32 com PlatformIO (VS Code)
- Simulador Wokwi.com
- C/C++ (para o firmware do ESP32)
- Python 3
- SQLite (banco de dados local)
- Machine Learning para an√°lise e predi√ß√£o de risco;
- Interface de alertas para moradores e autoridades.

---

## üß† L√≥gica do Projeto - Arquitetura de Dados

### Sensores Simulados

| Origem                | Tipo de dado                           | Destino                      |
| --------------------- | -------------------------------------- | ---------------------------- |
| Sensor de umidade     | Num√©rico cont√≠nuo                      | ESP32 ‚Üí LCD ‚Üí Banco de Dados |
| Sensor de nutrientes  | Num√©rico cont√≠nuo                      | ESP32 ‚Üí LCD ‚Üí Banco de Dados |
| Sensor de temperatura | Num√©rico cont√≠nuo                      | ESP32 ‚Üí Banco de Dados       |
| Predi√ß√£o de ML        | Bin√°rio (0 - alerta, 1 - normal)       | Streamlit ‚Üí ESP32            |


### Software Utilizado

| Componente          | Tecnologia                    |
| ------------------- | ----------------------------- |
| Sistema embarcado   | C/C++ para ESP32              |
| Monitoramento       | Serial Plotter (Wokwi)        |
| Exibi√ß√£o local      | LCD I2C                       |
| Modelagem preditiva | Python com Scikit-learn       |
| Dashboard           | Python com Streamlit          |
| Banco de dados      | MySQL / PostgreSQL / Firebase |
| Versionamento       | GitHub                        |


## Descri√ß√£o dos Componentes

* **Sensores:**

  * üî• Temperatura e Umidade (DHT11/DHT22)
  * üî• G√°s e Fuma√ßa (MQ-2, MQ-135)
 
* **ESP32:**

  * Coleta dados dos sensores;
  * Envia dados via Wi-Fi (MQTT ou HTTP) para o servidor.

* **Servidor com Machine Learning (Python):**

  * Recebe dados dos sensores em tempo real;
  * Executa modelo preditivo para avaliar risco de inc√™ndio;
  * Gera alertas com n√≠veis: **Baixo, Moderado, Alto, Cr√≠tico**.

* **Interface:**

  * Dashboard Web (opcional - Streamlit);
  * Alertas locais (buzzer, LED no ESP32);
  * Alertas digitais (e-mail, SMS ou notifica√ß√£o no dashboard).

---

## üó∫Ô∏è **Diagrama da Arquitetura**

```
[Sensores no Ambiente]
   ‚Üì
[ESP32] ---> [API/MQTT] ---> [Servidor com ML em Python]
                                     ‚Üì
                         [An√°lise + Predi√ß√£o de Risco]
                                     ‚Üì
              [Interface: Dashboard + Alertas (E-mail, LED, Buzzer)]
```

---

## **Hardware Utilizado**

* **ESP32** ‚Äî microcontrolador central.
* **Sensores** ‚Äî umidade, temperatura.
* **Servidor ou PC** ‚Äî para rodar modelo de ML e banco de dados.
* **PC com Streamlit** ‚Äî dashboard interativo.
 
---


---

##  üß† **Machine Learning**

### Tabelas ‚Äî Modelos de Machine Learning para o FireGuard

---

##### Modelos Recomendados

| Modelo                       | Vantagens                                                       | Desvantagens                                       | Aplica√ß√£o                                  |
| ---------------------------- | --------------------------------------------------------------- | -------------------------------------------------- | ------------------------------------------ |
| Random Forest                | Robusto, boa generaliza√ß√£o, interpreta vari√°veis importantes    | Pode ser mais lento com muitos dados               | Classifica√ß√£o multin√≠vel de risco          |
| Regress√£o Log√≠stica          | Simples, r√°pido, eficiente para classifica√ß√µes bin√°rias         | Pode ter baixa precis√£o em rela√ß√µes n√£o-lineares   | Classifica√ß√£o bin√°ria: risco ou n√£o        |
| Gradient Boosting (XGBoost)  | Alta precis√£o, bom para dados complexos                         | Mais lento para treinar, mais dif√≠cil de ajustar   | Classifica√ß√£o multin√≠vel de risco          |
| K-Nearest Neighbors (KNN)    | F√°cil implementa√ß√£o, funciona bem com poucos dados              | N√£o escala bem com grandes datasets                | Classifica√ß√£o baseada em vizinhos pr√≥ximos |
| Support Vector Machine (SVM) | Eficiente em alta dimens√£o, suporta classifica√ß√µes n√£o-lineares | Dif√≠cil de ajustar e interpretar, sens√≠vel a ru√≠do | Classifica√ß√£o com dados complexos          |

---

#### Vari√°veis de Entrada (Features)

| Vari√°vel                    | Tipo       | Origem                |
| --------------------------- | ---------- | --------------------- |
| Temperatura do ar (¬∞C)      | Num√©rico   | Sensor DHT11/DHT22    |
| Umidade relativa (%)        | Num√©rico   | Sensor DHT11/DHT22    |
| Concentra√ß√£o de gases (ppm) | Num√©rico   | Sensor MQ-2 ou MQ-135 |
| Fuma√ßa (ppm)                | Num√©rico   | Sensor MQ-2 ou MQ-135 |
| Hist√≥rico meteorol√≥gico     | Num√©rico   | Dados externos        |
| Hora do dia, data           | Categ√≥rico | Sistema interno       |

---

####  Vari√°vel de Sa√≠da (Target)

| Sa√≠da             | Tipo                     | Valores                        |
| ----------------- | ------------------------ | ------------------------------ |
| Risco de inc√™ndio | Classifica√ß√£o            | Baixo, Moderado, Alto, Cr√≠tico |
|                   | ou Classifica√ß√£o Bin√°ria | 0: Sem risco, 1: Com risco     |

---

#### Pipeline de Machine Learning

| Etapa             | Descri√ß√£o                                          |
| ----------------- | -------------------------------------------------- |
| Coleta de dados   | Dados do ESP32 ou datasets p√∫blicos                |
| Pr√©-processamento | Limpeza, normaliza√ß√£o, engenharia de atributos     |
| Treinamento       | Divis√£o em treino, valida√ß√£o e teste               |
| Avalia√ß√£o         | M√©tricas: Accuracy, Precision, Recall, F1, AUC-ROC |
| Deploy            | API local ou na nuvem, integra√ß√£o com ESP32        |

---

#### Bibliotecas Recomendadas (Python)

| Categoria             | Biblioteca                      |
| --------------------- | ------------------------------- |
| Modelos ML            | Scikit-learn, XGBoost, LightGBM |
| Manipula√ß√£o de Dados  | Pandas, NumPy                   |
| Visualiza√ß√£o          | Matplotlib, Seaborn             |
| Dashboard             | Streamlit                       |
| Comunica√ß√£o com ESP32 | Flask, FastAPI, MQTT libraries  |
| Versionamento         | GitHub                          |

---

#### Crit√©rios para Escolha do Modelo Final

| Crit√©rio                          | Import√¢ncia |
| --------------------------------- | ----------- |
| Acur√°cia                          | Alta        |
| Velocidade de infer√™ncia          | M√©dia/Alta  |
| Capacidade de interpreta√ß√£o       | Alta        |
| Facilidade de integra√ß√£o (Python) | Alta        |
| Robustez com dados ruidosos       | Alta        |

---

#### Resultado Esperado

| Resultado                                             | Benef√≠cio                               |
| ----------------------------------------------------- | --------------------------------------- |
| Classifica√ß√£o autom√°tica do risco de inc√™ndio         | A√ß√µes preventivas e resposta r√°pida     |
| Sistema de alertas preventivos                        | Prote√ß√£o ambiental e social             |
| Base para futuras integra√ß√µes com imagens de sat√©lite | Expans√£o do sistema para maior precis√£o |

---

**Justificativa:**

* O **ESP32** possui limita√ß√µes de mem√≥ria e processamento, inadequadas para executar modelos mais complexos de ML.
* A execu√ß√£o em um **servidor** ou **PC local** permite:

  * Utiliza√ß√£o de algoritmos como **Random Forest**, **Gradient Boosting**.
  * Treinamento e infer√™ncia mais r√°pidos.
  * Facilidade de integra√ß√£o com **Streamlit**.
* O **ESP32** receber√° apenas o resultado da predi√ß√£o (por exemplo, via MQTT, HTTP ou WebSocket).

---

## **Pipeline**

1. **Coleta:** Dados do ESP32 ou datasets hist√≥ricos;
2. **Pr√©-processamento:** Limpeza e padroniza√ß√£o dos dados;
3. **Treinamento:** Com algoritmos de classifica√ß√£o;
4. **Valida√ß√£o:** Testes de precis√£o, recall e F1-score;
5. **Deploy:** API local ou na nuvem para receber dados e retornar risco.

---

## üîÅ **Fluxo do Sistema**
1. **Reposit√≥rio publicado no Heroku**
A API foi implantada na nuvem utilizando o Heroku, permitindo que fique online e acess√≠vel para receber dados dos sensores.

2. **Sensor envia dados para o servidor (POST request)**
O dispositivo sensor (ex: ESP32) coleta dados ambientais (temperatura, umidade, etc.) e faz uma requisi√ß√£o POST para a API hospedada no Heroku.

3. **Dados s√£o armazenados no banco PostgreSQL**
Ao receber os dados, a API os registra em um banco de dados PostgreSQL, garantindo persist√™ncia e rastreabilidade.

4. **Requisi√ß√£o para obter o √∫ltimo registro**
O sistema realiza uma requisi√ß√£o GET para recuperar o √∫ltimo dado inserido no banco, servindo como entrada para o modelo de Machine Learning.

5. **Processamento com Machine Learning**
Os dados coletados s√£o analisados por um modelo de Machine Learning, que avalia a probabilidade de ocorr√™ncia de foco de inc√™ndio.

6. **Resultado encaminhado ao dashboard**
O resultado da an√°lise √© enviado para o dashboard, criado com a ferramenta Streamlit, que apresenta em tempo real a mensagem de risco ou tranquilidade, com base na √∫ltima atualiza√ß√£o.

## ‚úÖ **Funcionamento Esperado:**

* Monitoramento ambiental em tempo real;
* Detec√ß√£o de condi√ß√µes favor√°veis ao in√≠cio de inc√™ndios;
* Gera√ß√£o de alertas imediatos para preven√ß√£o.

## üåü **Benef√≠cios da Solu√ß√£o:**

* Efici√™ncia no combate preventivo;
* Prote√ß√£o ambiental e social;
* Redu√ß√£o dos custos operacionais;
* Sistema de baixo custo, escal√°vel e replic√°vel.

## üì∏ **Evid√™ncias:**

* Prints dos dashboards;
* Fotos do ESP32 com sensores funcionando;
* Prints dos alertas acionados;
* Print do modelo de ML rodando e processando dados.****

## üöß **Limita√ß√µes:**

* Acur√°cia dependente da qualidade dos sensores;
* Lat√™ncia na transmiss√£o dependendo da rede Wi-Fi;
* Dataset inicial pode ser limitado, precisando de mais dados reais para aumentar a precis√£o.

## üî• **Melhorias Futuras:**

* Integra√ß√£o com imagens de sat√©lite (NDVI, MODIS);
* Uso de LoRa para comunica√ß√£o de longa dist√¢ncia em √°reas sem Wi-Fi;
* Dashboard mobile para alertas mais r√°pidos;
* Inclus√£o de IA embarcada no pr√≥prio ESP32 (TinyML).

## 6. üìé **Anexos**

* ‚úîÔ∏è C√≥digos comentados (ESP32 e Python);
* ‚úîÔ∏è Diagramas el√©tricos do circuito (ESP32 + sensores);
* ‚úîÔ∏è Diagrama da arquitetura do sistema;
* ‚úîÔ∏è Link do v√≠deo de demonstra√ß√£o (**N√£o listado no YouTube**);
* ‚úîÔ∏è Refer√™ncias de datasets e bibliografia t√©cnica.

---

## üìÅ Estrutura de pastas

```bash
GLOBAL-SOLUTION-2025-1/
‚îú‚îÄ‚îÄ .git/
‚îú‚îÄ‚îÄ .venv/
‚îú‚îÄ‚îÄ api_sensor/
‚îÇ   ‚îú‚îÄ‚îÄ api_request/
‚îÇ   ‚îú‚îÄ‚îÄ sensor/
‚îÇ   ‚îú‚îÄ‚îÄ sensor_api/
‚îÇ   ‚îú‚îÄ‚îÄ staticfiles/
‚îú‚îÄ‚îÄ .gitignore
‚îú‚îÄ‚îÄ manage.py
‚îú‚îÄ‚îÄ Procfile
‚îú‚îÄ‚îÄ README.md
‚îú‚îÄ‚îÄ requirements.txt
‚îú‚îÄ‚îÄ runtime.txt
‚îú‚îÄ‚îÄ dashboard/
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îî‚îÄ‚îÄ app.py
‚îú‚îÄ‚îÄ ml/
‚îÇ   ‚îú‚îÄ‚îÄ __pycache__/
‚îÇ   ‚îú‚îÄ‚îÄ data/
‚îÇ   ‚îú‚îÄ‚îÄ models/
‚îÇ   ‚îú‚îÄ‚îÄ notebooks/
‚îÇ   ‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ README.md
‚îÇ   ‚îú‚îÄ‚îÄ requirements.txt
‚îú‚îÄ‚îÄ sensor_circuit/
‚îÇ   ‚îú‚îÄ‚îÄ .pio/
‚îÇ   ‚îú‚îÄ‚îÄ .vscode/
‚îÇ   ‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ .gitignore
‚îÇ   ‚îú‚îÄ‚îÄ diagram.json
‚îÇ   ‚îú‚îÄ‚îÄ platformio.ini
‚îÇ   ‚îú‚îÄ‚îÄ wokwi.toml
‚îÇ   ‚îú‚îÄ‚îÄ esp32_estudo_funcionamento.md
‚îÇ   ‚îú‚îÄ‚îÄ LICENSE
‚îú‚îÄ‚îÄ .gitignore
‚îú‚îÄ‚îÄ main.py
‚îú‚îÄ‚îÄ pip
‚îú‚îÄ‚îÄ README.md
‚îî‚îÄ‚îÄ requirements.txt
```

## ‚ñ∂Ô∏è Como utilizar:

üíæ Instala√ß√£o
---
1. clone o reposit√≥rio:
```

```
2. Crie e ative um ambiente virtual (opcional, mas recomendado):
```
python -m venv venv
source venv/bin/activate      # Linux/macOS
venv\Scripts\activate         # Windows
```
3. Instale as bibliotecas necess√°rias:
```
pip install -r requirements.txt
```

üîß 1. Preparar o Dispositivo Sensor
---
1. Acesse o sensor pelo link https://wokwi.com/projects/432764471641420801;
2. Acione o sensor clicando no bot√£o verde de "play";
3. Acesse o Dashboard (Streamlit)
4. V√° at√© a pasta dashboard/.
5. Execute o seguinte comando:
   ```
   streamlit run app.py
6. O dashboard ser√° aberto no navegador, mostrando a √∫ltima predi√ß√£o com base nos dados recebidos.
7. Acesse via navegador: http://localhost:8501
   
---

üöÄ **Fluxo Resumido**
Sensor ‚Üí envia dados via POST

API (Heroku) ‚Üí armazena no PostgreSQL

ML ‚Üí analisa o √∫ltimo dado

Dashboard (Streamlit) ‚Üí mostra se h√° risco de inc√™ndio

---

## üìã Licen√ßa

<img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/cc.svg?ref=chooser-v1"><img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/by.svg?ref=chooser-v1"><p xmlns:cc="http://creativecommons.org/ns#" xmlns:dct="http://purl.org/dc/terms/"><a property="dct:title" rel="cc:attributionURL" href="https://github.com/agodoi/template">MODELO GIT FIAP</a> por <a rel="cc:attributionURL dct:creator" property="cc:attributionName" href="https://fiap.com.br">Fiap</a> est√° licenciado sobre <a href="http://creativecommons.org/licenses/by/4.0/?ref=chooser-v1" target="_blank" rel="license noopener noreferrer" style="display:inline-block;">Attribution 4.0 International</a>.</p>
